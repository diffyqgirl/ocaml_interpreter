(** A mini-ML
    @author Stuart M. Shieber

    This module implements a small untyped ML-like language under
    various operational semantics.
 *)

open Expr ;;
  
(* Exception for evaluator runtime generated by a runtime error *)
exception EvalError of string ;;
(* Exception for evaluator runtime generated by an explicit "raise" construct*)
exception EvalException ;;

module type Env_type = sig
    type env
    type value =
       | Val of expr
       | Closure of (expr * env)
    val create : unit -> env
    val close : expr -> env -> value
    val lookup : env -> varid -> value
    val extend : env -> varid -> value ref -> env
    val env_to_string : env -> string
    val value_to_string : ?printenvp:bool -> value -> string
  end

module Env : Env_type =
  struct

    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    exception EnvUnbound

    (* Creates an empty environment *)
    let create () : env = [] ;;

    (* Creates a closure from an expression and the environment it's
       defined in *)
    let close (exp: expr) (env: env) : value =
      Closure (exp, env) ;;

    (* Looks up the value of a variable in the environment *)
    let lookup (env: env) (varname: varid) : value =
      !(List.assoc varname env) ;;

    (* Returns a new environment just like env except that it maps the
       variable varid to loc *)
    let extend (env: env) (varname: varid) (loc: value ref) : env =
      (varname, loc) :: (List.remove_assoc varname env)

    (* Returns a printable string representation of an environment *)
    let rec env_to_string (env: env) : string =
      match env with
      | (a, b) :: t -> 
        "(" ^ a ^ ", " ^ (value_to_string !b) ^ "), " ^ (env_to_string t)
      | [] -> "\n"
    

    (* Returns a printable string representation of a value; the flag
       printenvp determines whether to include the environment in the
       string representation when called on a closure *)
    and value_to_string ?(printenvp : bool = true) (v: value) : string =
      match v with
      | Val exp -> exp_to_string exp
      | Closure (exp, env) -> if printenvp 
        then "(" ^ (exp_to_string exp) ^ ", " ^ (env_to_string env) ^ ")" 
        else exp_to_string exp ;;
  end
;;
	     
(* The evaluation function: Returns the result of type `value` of
   evaluating the expression `exp` in the environment `env`. In this
   initial implementation, we just convert the expression unchanged to
   a value and return it. *)


let eval_t exp _env = Env.Val exp ;;
let rec eval_s exp _env = 
  let rec eval_s_h exp: expr = 
  match exp with
  | Var v -> raise (EvalError "unbound variable")
  | Num _ -> exp
  | Bool _ -> exp
  | Unop (op, exp1) ->  let new_exp1 = eval_s_h exp1 in (match new_exp1 with
    | Num n -> Num (~- n)
    | _ -> eval_s_h (Unop (op, new_exp1)))
  | Binop (op, exp1, exp2) -> 
    if op = "=" then Bool (eval_s_h exp1 = eval_s_h exp2) 
    else (match eval_s_h exp1, eval_s_h exp2 with
    | Num n, Num m -> (match op with
      | "+" -> Num (n + m)
      | "*" -> Num (n * m)
      | "-" -> Num (n - m)
      | "<" -> Bool (n < m)
      | _ -> raise (EvalError "invalid binary operation"))
    | _ -> Binop (op, eval_s_h exp1, eval_s_h exp2))
  | Conditional (exp1, exp2, exp3) -> (match eval_s_h exp1 with
    | Bool b -> if b then eval_s_h exp2 else eval_s_h exp3
    | _ -> raise (EvalError "invalid conditional"))
  | Fun (v, exp1) -> exp
  | Let (v, exp1, exp2) -> eval_s_h (subst v exp1 exp2)
  | Letrec (v, exp1, exp2) -> 
      let exp3 = eval_s_h (subst v (Letrec (v, exp1, Var v)) exp1) in 
      eval_s_h (subst v exp3 exp2) 
  | Raise -> exp
  | Unassigned -> raise (EvalError "unassigned variable")
  | App (exp1, exp2) -> (match eval_s_h exp1 with
    | Fun (v, f) -> let exp2_val = eval_s_h exp2 in 
        eval_s_h (subst v exp2_val f)
    | _ -> raise (EvalError ("invalid function application")))
  in Env.Val (eval_s_h exp)
;;

let eval_d exp env = 
  let rec eval_d_h exp env: expr = 
  match exp with
  | Var v -> (match (Env.lookup env v) with
    | Env.Val exp -> exp
    | Env.Closure (exp, _) -> exp)
  | Num _ -> exp
  | Bool _ -> exp
  | Unop (op, exp1) -> (let new_exp1 = eval_d_h exp1 env in match new_exp1 with
    | Num n -> Num (~- n)
    | _ -> eval_d_h (Unop (op, new_exp1)) env)
  | Binop (op, exp1, exp2) -> (match eval_d_h exp1 env, eval_d_h exp2 env with
      | Num n, Num m -> (match op with
        | "+" -> Num (n + m)
        | "*" -> Num (n * m)
        | "-" -> Num (n - m)
        | "<" -> Bool (n < m)
        | "=" -> Bool (n = m)
        | _ -> raise (EvalError "invalid binary operation"))
      | Bool b1, Bool b2 -> Bool ((b1 && b2) || ((not b1) && (not b2)))
      | _ -> eval_d_h (Binop (op, eval_d_h exp1 env, eval_d_h exp2 env)) env)
  | Conditional (exp1, exp2, exp3) -> (match eval_d_h exp1 env with
    | Bool b -> if b then eval_d_h exp2 env else eval_d_h exp3 env
    | _ -> raise (EvalError "invalid conditional"))
  | Fun (v, exp1) -> exp
  | Let (v, exp1, exp2) -> 
      eval_d_h exp2 (Env.extend env v (ref (Env.Val exp1)))
  | Letrec (v, exp1, exp2) -> eval_d_h exp2 (Env.extend env v (ref (Env.Val
      (eval_d_h exp1 (Env.extend env v (ref (Env.Val Unassigned)))))))
  | Raise -> exp
  | Unassigned -> raise (EvalError ("unassigned variable"))
  | App (exp1, exp2) -> (match eval_d_h exp1 env with
    | Fun (v, f) -> 
      eval_d_h f (Env.extend env v (ref (Env.Val (eval_d_h exp2 env))))
    | _ -> raise (EvalError ("invalid function application")))
in Env.Val (eval_d_h exp env)
;;

let rec eval_l exp env = 
  match exp with
  | Var v -> Env.lookup env v
  | Num _ -> Env.Val exp
  | Bool _ -> Env.Val exp
  | Unop (op, exp1) -> (match eval_l exp1 env with
    | Env.Val (Num n) -> Env.Val (Num (~- n))
    | Env.Val exp2 -> eval_l (Unop (op, exp2)) env
    | _ -> raise (EvalError ("unop of a closure")))
  | Binop (op, exp1, exp2) -> (match eval_l exp1 env, eval_l exp2 env with
      | (Env.Val (Num n)), (Env.Val (Num m)) -> (match op with
        | "+" -> Env.Val (Num (n + m))
        | "*" -> Env.Val (Num (n * m))
        | "-" -> Env.Val (Num (n - m))
        | "<" -> Env.Val (Bool (n < m))
        | "=" -> Env.Val (Bool (n = m))
        | _ -> raise (EvalError "invalid binary operation"))
      | (Env.Val (Bool b1)), (Env.Val (Bool b2)) -> 
          Env.Val (Bool ((b1 && b2) || ((not b1) && (not b2))))
      | (Env.Val e1), (Env.Val e2) -> eval_l (Binop (op, e1, e2)) env
      | _ -> raise (EvalError ("Binop of a closure")))
  | Conditional (exp1, exp2, exp3) -> (match eval_l exp1 env with
    | Env.Val (Bool b) -> if b then eval_l exp2 env else eval_l exp3 env
    | _ -> raise (EvalError "invalid conditional"))
  | Fun (v, exp1) -> Env.Closure (exp, env)
  | Let (v, exp1, exp2) -> eval_l (App (Fun(v, exp2), exp1)) env
  | Letrec (v, exp1, exp2) -> let tempref = ref (Env.Val Unassigned) in
    let evaled = ref (eval_l exp1 (Env.extend env v tempref)) in
    (tempref := !evaled; eval_l exp2 (Env.extend env v evaled ))
  | Raise -> Env.Val exp
  | Unassigned -> raise (EvalError ("unassigned variable"))
  | App (exp1, exp2) -> (match eval_l exp1 env with
    | Env.Closure (Fun (v, f), env2) -> 
      eval_l f (Env.extend env2 v (ref (eval_l exp2 env))) 
    | _ -> raise (EvalError ("invalid function application")))
;;


let evaluate = eval_l ;;

(*Generic test function for all 3 eval functions*)
let run_tests eval_fun env : unit =
  (* 3 = 3*)
  (assert (eval_fun (Num (3)) env = Env.Val (Num (3)))) ;
  (* 3 + 3 = 6 *)
  (assert (eval_fun (Binop ("+", Num (3), Num (3))) env = Env.Val (Num (6)))) ;
  (* ~. 3 = (~. 3) *)
  (assert (eval_fun (Unop ("~", Num (3))) env = Env.Val (Num (~- 3)))) ;
  (* (if 4 = 3 then 1 else 0) = 0 *)
  (assert (eval_fun (Conditional (Binop ("=", Num (4), Num (3)), Num (1), 
    Num (0))) env = Env.Val (Num (0)))) ;
  (* (fun x -> 2 * x) 2 = 4 *)
  (assert (eval_fun (App(Fun ("x", Binop("*", Num(2), Var("x"))), Num (2))) env
    = Env.Val (Num (4)))) ;
  (* (let f = fun x -> ~- x in f (~- 5)) = 5 *)
  (assert (eval_fun (Let ("f", Fun ("x", Unop ("~", Var("x"))), App(Var("f"), 
    Unop("~", Num (5))))) env = Env.Val (Num (5)))) ;
  (* (let f = fun x -> x in f f 3) = 3*)
  (assert (eval_fun (Let("f", Fun("x", Var("x")), App(App(Var("f"), Var("f")),
    Num(3)))) env = Env.Val (Num (3)))) ;
  (* (let rec f = fun x -> if x = 0 then 1 else x * f (x - 1) in f 4) = 24 *)
  (assert (eval_fun (Letrec("f", Fun("x", Conditional(Binop("=", Var("x"), 
    Num(0)), Num(1), Binop("*", Var("x"), App(Var("f"), Binop("-", Var("x"),
    Num(1)))))), App(Var("f"), Num(4)))) env = Env.Val (Num (24)))) ;
  (*  let f = fun x -> x + 1 in let g = fun x -> (f x) * (f x) in g 3 *)
  (assert (eval_fun (Let("f", Fun("x", Binop("+", Var("x"), Num(1))), Let("g",
   Fun("x", Binop("*", App(Var("f"), Var("x")), App(Var("f"), Var("x")))), 
   App(Var("g"), Num(3))))) env = Env.Val (Num (16)))) ;
  (* (let f = fun x -> if x < 0 then 0 else 1 in f 9) = 1*)
  (assert (eval_fun (Let("f", Fun("x", Conditional(Binop("<", Var("x"), 
    Num(0)), Num(0), Num(1))), App(Var("f"), Num(9)))) env =
    Env.Val (Num (1)))) ;
  () ;;

(*Test function to test the cases where dynamic and lexical scoping should 
 * produce different results, which I can't do using the regular run_tests
 * function.*)
let test_scoping env : unit =  
  (*(let x = 7 in let rec f = fun y -> if y = 0 then x else y * f (y - 1) in 
  * let x = 9 in f 3) = 42 *)
  (assert (eval_l ( Let("x", Num(7), Letrec("f", Fun("y", Conditional(Binop("="
    , Var("y"), Num(0)), Var("x"), Binop("*", Var("y"), App(Var("f"), Binop("-"
    , Var("y"), Num(1)))))), Let("x", Num(9), App(Var("f"), Num(3)))))) env =
    Env.Val (Num (42))));
  (*(let x = 7 in let rec f = fun y -> if y = 0 then x else y * f (y - 1) in 
  * let x = 9 in f 3) = 54 *)
  (assert (eval_d ( Let("x", Num(7), Letrec("f", Fun("y", Conditional(Binop("="
    , Var("y"), Num(0)), Var("x"), Binop("*", Var("y"), App(Var("f"), Binop("-"
    , Var("y"), Num(1)))))), Let("x", Num(9), App(Var("f"), Num(3)))))) env =
    Env.Val (Num (54)))) ;
  (*( let y = 5 in let f = fun x -> x + y in let y = 3 in f 1) = 6*)
  (assert (eval_l ( Let("y", Num(5), Let("f", Fun("x", Binop("+", Var("x"), 
    Var("y"))), Let("y", Num(3), App(Var("f"), Num(1)))))) env = 
    Env.Val (Num (6)))) ;
  (*( let y = 5 in let f = fun x -> x + y in let y = 3 in f 1) = 4*)
  (assert (eval_d ( Let("y", Num(5), Let("f", Fun("x", Binop("+", Var("x"),
    Var("y"))), Let("y", Num(3), App(Var("f"), Num(1)))))) env = 
    Env.Val (Num (4)))) ;;

let empty = Env.create () in
(run_tests eval_s empty) ;
(run_tests eval_d empty) ;
(run_tests eval_l empty) ;
(test_scoping empty) ;;

